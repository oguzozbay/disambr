#+title: NEDR - Named Entity Disambiguation in R
#+author: Stanislav A. Vlasov
#+email: stanislav.a.vlasov@gmail.com
# ------------------------------------------------------------------------------

#+PROPERTY: header-args:R :comments link  :session

Description: file:readme.org

* Make & Deploy
#+BEGIN_SRC emacs-lisp
  ;; tangle source code
  (org-babel-tangle)
  ;; run package deployment scripts
  (let ((org-confirm-babel-evaluate nil))
	(save-excursion
	  (org-babel-goto-named-src-block "document")
	  (org-babel-execute-src-block)))
#+END_SRC
** Package documentation
:PROPERTIES:
:ID:       org:g01ja7119ri0
:END:
#+BEGIN_SRC R :tangle R/disambr.r
  #' @details
  #' This package provides a framework for disambiguating named entities (e.g., authors in large bibliometric databases)
  #' 
  #' Package provides following main functions
  #' - disambr_read - reads WoS data
  #' - disambr_aev - implementation of the AEV algorithm (van den Akker et al., 2020) for Web of Science author disambiguation.
  #' 
  #' This is work in progress. Please, file an issues or suggestion if you have any.
  #' @keywords internal
  "_PACKAGE"
#+END_SRC
** Set .Rprofile (developer enviroment)
*** CRAN Packages
:PROPERTIES:
:ID:       org:ihcia7119ri0
:END:
#+BEGIN_SRC R :tangle .Rprofile
  ## --------------------------------------------------------------------------------
  ## First load default packages getOption("defaultPackages")
  ## Otherwise it will add it at the end which can mask some funcitons
  .First.sys()


  ## some packages installations read .Rprofile loops the install
  current_wd <- getwd()
  setwd("~/")

  ## --------------------------------------------------------------------------------
  ## Load or Install Packages
  ## --------------------------------------------------------------------------------
  for(pkg in c('devtools'
             , 'roxygen2'
             , 'xml2'
             , 'tibble'
             , 'stringi'
             , 'stringr'
             , 'stringdist'
             , 'digest'
             , 'magrittr'
             , 'lubridate'
             , 'plyr'
             , 'pipeR'
             , 'ggplot2'
             , 'pbapply'
             , 'microbenchmark'
             , 'data.table'
             , 'dplyr'))
      if(!require(pkg, character.only = TRUE)) {
          install.packages(pkg, repos = 'http://cloud.r-project.org')
          require(pkg, character.only = TRUE) }


  ## restore current working directore
  setwd(current_wd)

  ## --------------------------------------------------------------------------------
  library(disambr)

  ## update.packages(ask = FALSE, repos = 'http://cloud.r-project.org')

#+END_SRC
*** My Packages
:PROPERTIES:
:ID:       org:hzuia7119ri0
:END:
#+BEGIN_SRC R :results silent :session :tangle no
  ## --------------------------------------------------------------------------------
  ## Load My pakcages
  ## --------------------------------------------------------------------------------
  ## detach(package:romRDS, unload = TRUE)
  ## remove.packages("romRDS")
  if (!require("romRDS", character.only = TRUE)) {
    if(!require("devtools")) {
      install.packages("devtools"
                     , repos = 'http://cloud.r-project.org'
                     , dependencies = TRUE)
      require("devtools", character.only = TRUE)
    }
    install_github("stasvlasov/romRDS")
    require("romRDS", character.only = TRUE)
  }
  ## --------------------------------------------------------------------------------
#+END_SRC
** Set up package
#+name: document
#+BEGIN_SRC R :results none :tangle no

  .First.sys()

  ## --------------------------------------------------------------------------------
  ## Load or Install Packages
  ## --------------------------------------------------------------------------------
  for(pkg in c('devtools'
             , 'roxygen2'
             , 'xml2'
             , 'tibble'
             , 'stringi'
             , 'stringr'
             , 'stringdist'
             , 'digest'
             , 'magrittr'
             , 'lubridate'
             , 'plyr'
             , 'pipeR'
             , 'ggplot2'
             , 'microbenchmark'
             , 'data.table'
             , 'dplyr'))
    if(!require(pkg, character.only = TRUE)) {
      install.packages(pkg, repos = 'http://cloud.r-project.org')
      require(pkg, character.only = TRUE)
    }
  ## --------------------------------------------------------------------------------

  ## Describint package
  ## --------------------------------------------------------------------------------

  ## Include packages:
  package.packages <- c(
      "data.table"
    , "magrittr"
    , "stringi"
    , "stringr"
    , "tibble"
    , "xml2"
    , "dplyr")

  ## Print current packages verstions
  ## package.packages %>%
  ##     sapply(function(pkg)
  ##     paste0(pkg, " (>= ", packageVersion(pkg), ")"), USE.NAMES = FALSE) %>%
  ##     cat(sep = "\n")

  ## Adjust verstions manually
  package.packages.man.ver  <- c(
      "data.table (>= 1.12)"
    , "magrittr (>= 1.5)"
    , "stringi (>= 1.4)"
    , "stringr (>= 1.4)"
    , "dplyr (>= 0.8)"
    , "tibble (>= 2.0)"
    , "xml2 (>= 1.0)"
  )

  ## make description
  list(Package = "disambr"
     , Title  = "disambr - Named Entity Disambiguation in R"
     , Description = "disambr - Named Entity Disambiguation in R"
     , `Authors@R` = c(person(given = c("Stanislav" ,"A.") , family = "Vlasov"
                     , email = "stanislav.a.vlasov@gmail.com"
                     , role = c("aut", "cre"))
              , person(given = c("Olmo", "R."), family = "van den Akker"
                     , email = "ovdakker@gmail.com"
                     , role = "aut")
              , person(given = "Sacha", family = "Epskamp"
                     , email = "sacha.epskamp@gmail.com"
                     , role = "aut"))
     , Imports = paste(package.packages.man.ver
                     , collapse = ", ")
     , Depends = "R (>= 3.4)"
     , Version = "0.1"
     , Date = Sys.Date()
     , URL = "https://github.com/stasvlasov/disambr"
     , BugReports = "https://github.com/stasvlasov/disambr/issues"
     , References = "This research was supported (in part) by the Fetzer Franklin Fund of the John E. Fetzer Memorial Trust.\n\nvan den Akker, O. R., Epskamp, Sacha, & Vlasov, S. A. (2020). The AEV Algorithm—Author name disambiguation for large Web of Science datasets."
           ) %>% use_description()

  use_lgpl_license(name = "Stanislav Vlasov")

  use_tidy_description()

  ## ----------------------------------------------------------------------------
  ## Update name spaces and documentation for functions
  roxygenise()


  ## This function is a wrapper for the ‘roxygen2::roxygenize()’ but also load the package
  ## document()

  ## ----------------------------------------------------------------------------
  ## Set up TestThat
  usethis::use_testthat()
#+END_SRC
** Deploy package
#+BEGIN_SRC R :tangle no
  ## Deploy
  ## --------------------------------------------------------------------------------
  install(".")

  install_github("stasvlasov/disambr")

  ## Test
  ## --------------------------------------------------------------------------------
  library("disambr")

  ## Remove
  ## --------------------------------------------------------------------------------
  detach(package:and, unload = TRUE)
  remove.packages("disambr")


  ## Just loadding
  ## --------------------------------------------------------------------------------

#+END_SRC

#+BEGIN_SRC R :tangle no
  source("R/disambr_utils.r")
  source("R/disambr_read.r")
  source("R/disambr_eva.r")
  source("R/disambr_sets.r")
#+END_SRC
* Functions
** disambr_utils
*** get_file_extension
:PROPERTIES:
:ID:       org:s6sdaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_utils.r
  ##' Extention extractor. Same as tools::file_ext but for NULL input returns NULL instead of logical(0).
  ##' @param f file name 
  ##' @return extention
  ##' 
  ##' @importFrom magrittr %>%
  ##' @export 
  get_file_extension <- function(f) {
      if(length(f) == 1) {
          if(is.character(f)) {
              f %>% basename %>% 
                  stringi::stri_split_fixed(".") %>% 
                  extract2(1) %>%
                  extract(ifelse(length(.) == 1, NA, length(.))) %>%
                  ifelse(is.na(.), "", .)
          } else if(is.na(f)) {
              NA
          }
      } else {
          NULL
      }
  }

  ## my.file <- '../data/Journals in Mathematical Psychology/Applied Psychological Measurement.txt' 
  ## my.file1 <- "/mnt/md5/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments/LN Public NAICS records from 10001 to 10500.txt"

  ## get_file_extension(my.file)
  ## get_file_extension(my.file1)
  ## get_file_extension("sdfsdf....")
  ## get_file_extension("sdf")
  ## get_file_extension("")
  ## get_file_extension(NULL)
  ## get_file_extension(NA)
  ## get_file_extension("...sdf...sdf.df...sd.")
  ## get_file_extension(".")
  ## get_file_extension(".....")

  ## build in
  ## tools::file_ext(my.file)
  ## tools::file_ext(my.file1)
  ## tools::file_ext("sdfsdf....")
  ## tools::file_ext("sdf")
  ## tools::file_ext("")
  ## tools::file_ext(NULL)
  ## tools::file_ext(NA)
  ## tools::file_ext("...sdf...sdf.df...sd.")
  ## tools::file_ext(".")
  ## tools::file_ext(".....")
#+END_SRC
*** stop_unless
:PROPERTIES:
:ID:       org:ptydaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_utils.r
  ##' Stops process unless cond is true
  ##' @param cond condition to test
  ##' @param message_if_false message_if_false
  ##' @param stop_if_false stop_if_false 
  ##' @param return_if_true return_if_true
  ##' @param return_if_false return_if_false 
  ##' @return 
  ##' 
  ##' @export 
  stop_unless <- function(cond
                        , message_if_false = paste("cond in not TRUE")
                        , stop_if_false = TRUE
                        , return_if_true = TRUE
                        , return_if_false = isFALSE(return_if_true)) {
      if(isTRUE(cond)) {
          return(return_if_true)
      } else if(isTRUE(stop_if_false)){
          stop(message_if_false, call. = FALSE)
      } else {
          warning(message_if_false, call. = FALSE)
          return(return_if_false)
      }
  }
#+END_SRC
*** parse_files_path
:PROPERTIES:
:ID:       org:kb3eaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_utils.r
##' Returns vector of file paths from path(s) recursively
  ##' @param files_path Path(s) where the files are
  ##' @param recursive Whether to look in subfolders recursively
  ##' @return Vector of file paths from path(s) recursively
  ##' 
  ##' @md
  ##' @importFrom magrittr %>%
  ##' @export 
  parse_files_path <- function(files_path, recursive = TRUE) {
      stop_unless(is.character(files_path), "Files path shoud be a character string!")
      files_path <- 
      lapply(files_path, function(file.path) {
          if(stop_unless(file.exists(file.path)
                       , paste(file.path, " - does not exist!")
                       , stop_if_false = FALSE
                       , return_if_true = FALSE)) {
              NULL
          } else if(dir.exists(file.path)) {
              dir(file.path
                , full.names = TRUE
                , recursive = recursive)
          } else {
              file.path
          }
      })
      return(unique(normalizePath(unlist(files_path))))
  }
#+END_SRC



*** read_to_utf8
:PROPERTIES:
:ID:       org:wx7eaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_utils.r
read_to_utf8 <- function(f, bytes_to_check = 2^14) {
    ## read file as raw bytes (not to Assume any encodings)
    bin <- readBin(f, raw(), n = file.size(f))
    ## check first 2^14 bytes for encoding
    encoding <- stringi::stri_enc_detect2(bin[1:bytes_to_check])[[1]][[1]][1]
    if(is.na(encoding)) {
        message("Could not detect encoding of file: ", f)
        s <- rawToChar(bin, multiple = FALSE)
    } else if(!(encoding %in% iconvlist())) {
        message("Does not know how to convert from ", encoding, "for file: ", f)
    } else if(encoding == "UTF8") {
        s <- rawToChar(bin, multiple = FALSE)
    } else {
        ## message("Converting to utf-8")
        s <- iconv(list(NULL, bin), from = encoding, to = "UTF-8")
    }
    return(s)
}

## stringi::stri_enc_detect2(NULL)[[1]][[1]][1]
## stringi::stri_enc_detect2(NA)[[1]][[1]][1]
## stringi::stri_enc_detect2(123)[[1]][[1]][1]
## stringi::stri_enc_detect2("")[[1]][[1]][1]
## stringi::stri_enc_detect2("sadf")[[1]][[1]][1]

#+END_SRC


*** recode_return_characters
:PROPERTIES:
:ID:       org:xbceaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_utils.r
recode_return_characters <- function(s, assoc.file = NA, verbose = FALSE) {
    has_return_chars <- function(s, test.first.n.char = 10^4) {
        s <- stri_sub(s, to = test.first.n.char)
        any(stri_detect_regex(s, "\\r"))
    }
    if(has_return_chars(s)) {
        if(verbose) message("'\\r' characters in the file: ", assoc.file
                          , "\n Removing to fix 'datatable::fread'")
        s <- stri_replace_all_regex(s, "\\R+", "\n")
    }
    return(s)
}
#+END_SRC


*** disambr_cbind_lists
#+BEGIN_SRC R :tangle no
##' Makes list of each element of l
##' @param l sequence or list
##' @param l.name same name will be applies to each element
##' @return list of lists
##' 
##' @export 
disambr_listify_list <- function(l, l.name = NULL) {
    if(isTRUE(l.name == "")) l.name =  NULL
    ## case when all are 1 length (vector or list of single length elements)
    lapply(l, function(x) {
        x <- list(x)
        names(x) <- l.name
        return(x)
    })
}


##' cbinds lists and names each element as name of each list in ...
##' @param ... Lists to cbin
##' @return Lists
##' @export 
disambr_cbind_lists <- function(...) {
    lists <- eval(...)
    lists_n <- length(lists)
    lists_names <- names(lists)
    cbind_list <- disambr_listify_list(lists[[1]], lists_names[1])
    for (i in 2:lists_n) {
        cbind_list <- 
            mapply(c
                 , cbind_list
                 , disambr_listify_list(lists[[i]], lists_names[i])
                 , SIMPLIFY = FALSE)
    }
    return(cbind_list)
}

#+END_SRC

** disambr_eject
:PROPERTIES:
:ID:       org:55peaz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_read.r
  ##' Parses AU column of WoS saved records export
  ##' @param record.au a record string from AU column
  ##' @return data.table
  ##' 
  ##' @md 
  disambr_eject_authors_parse_au <- function(record_au) {
      author_name <- stringi::stri_split_fixed(record_au, "; ")[[1]]
      author_last_name <-
          stringi::stri_extract_first_regex(author_name, "^[^,]+")
      author_initials <-
          stringi::stri_extract_first_regex(author_name, "(?<=, )[A-Z]+")
      data.table::data.table(author_name = author_name
                           , author_last_name = author_last_name
                           , author_initials = author_initials
                           , author_order = 1:length(author_name))
  }


  ## tests

  ## "Tilly, TB; Nelson, MT; Chakravarthy, KB; Shira, EA; Debrose, MC; Grabinski, CM; Salisbury, RL; Mattie, DR; Hussain, SM" %>% 
  ## disambr_eject_authors_parse_au




  ##' Parses AF (author full name) column of WoS saved records export
  ##' @param record.au a record string from AF column
  ##' @return Data.table
  disambr_eject_authors_parse_af <- function(record_af) {
      name <- stringi::stri_split_fixed(record_af, "; ")[[1]]
      last_name <- stringi::stri_extract_first_regex(name, "^[^,]+")
      first_names <- stringi::stri_extract_first_regex(name, "(?<=, ).*")
      first_names <-
          stringi::stri_split_fixed(first_names, " ", omit_empty = TRUE)
      ## first.full.name is first name without dot
      first_full_name <-
          lapply(first_names, function(n) {
              n[!stringi::stri_detect_regex(n, "\\.$")][1]
          })
      ## return
      data.table::data.table(
                      author_full_name = name
                    ## , author_last_name = last_name 
                    , author_first_names = first_names
                    , author_first_full_name =  first_full_name)
  }


  ## test
  ## "Tilly, Trevor B.; Nelson, M. Tyler; Chakravarthy, Karthik B.; Shira, Emily A.; Debrose, Madeline C.; Grabinski, Christin M.; Salisbury, Richard L.; Mattie, David R.; Hussain, Saber M." %>%
  ## disambr_eject_authors_parse_af


  ##' Parses RP (reprint author) column of WoS saved records export
  ##' @param record_rp a record string from RP column
  ##' @return Data.table with two columns -  author_name and affiliations
  disambr_eject_authors_parse_rp <- function(record_rp) {
      record_rp_init <- ""
      authors_table <-
          data.table::data.table(author_name = character(0)
                               , affiliations = character(0))
      while(record_rp != record_rp_init) {
          record_rp_init <- record_rp
          record_rp_split <- 
              stringi::stri_match_first_regex(
                           record_rp
                         , "\\s*([^()]+)\\s+\\((corresponding author|reprint author)\\)([^;]+)")
          authors <-
              stringi::stri_split_fixed(record_rp_split[1,2], "; ")[[1]]
          affiliation <-
              stringi::stri_replace_first_regex(
                           record_rp_split[1,4], "^[\\s,.;]+", "")
          for (author in authors) {
              ## check if author is already in the list
              authors_table_match <-
                  authors_table$author_name %in% author
              if(any(authors_table_match)) {
                  ## add affiliation to affiliations of author
                  ## the data.table way..
                  authors_table[authors_table_match
                              , affiliations :=
                                    list(c(unlist(affiliations), affiliation))]
              } else {
                  ## add new author with affiliation otherwise
                  authors_table <-
                      data.table::rbindlist(
                                      list(authors_table
                                         , list(author_name = author
                                              , affiliations =
                                                    list(affiliation))))
              }
          }
          record_rp <-
              stringi::stri_replace_first_regex(
                           record_rp
                         , "[^()]+\\((corresponding author|reprint author)\\)[^;]+[;]", "")
      }
      ## results are not printed but the data.table is returned
      return(authors_table)
  }

  ## "Guesmi, S (corresponding author), Natl Agron Inst Tunisia INAT, 43 Ave Charles Nicolle, Tunis 1082, Tunisia.; Guesmi, S; Sghaier, H (corresponding author), Sidi Thabet Technopk, Natl Ctr Nucl Sci & Technol, Lab Energy & Matter Dev Nucl Sci LR16CNSTN02, Sidi Thabet 2020, Tunisia.; Sghaier, H (corresponding author), Sidi Thabet Technopk, Lab Biotechnol & Nucl Technol LR16CNSTN01, Sidi Thabet 2020, Tunisia.; Sghaier, H (corresponding author), Sidi Thabet Technopk, Lab Biotechnol & Biogeo Resources Valorizat LR11E, Sidi Thabet 2020, Tunisia." %>%
  ## disambr_eject_authors_parse_rp %>% print

  ## "" %>%
  ## disambr_eject_authors_parse_rp %>% nrow


  ##' Parses EM (email) column of WoS saved records export
  ##' @param record_em  a record string from EM column
  ##' @param record_au_table a data_tabe after parsing AU column with disambr_eject_authors_parse_au
  ##' @param record_rp_table a data_tabe after parsing RP column with disambr_eject_authors_parse_rp
  ##' @return Data.table with columns - author_name, affiliations and email
  disambr_eject_authors_parse_em <- function(record_em
                                           , record_au_table
                                           , record_rp_table) {
      emails <- stringi::stri_split_fixed(record_em, "; ")[[1]]
      if (isTRUE(length(emails) == 1 && emails == "")) {
          ## in case there are no emails
          record_au_table[, author_email := NA]
      } else if (isTRUE(length(emails) == nrow(record_rp_table))) {
          ## assume that emails corresponds RP authors
          record_au_table[match(record_rp_table$author_name, author_name)
                        , author_email := emails]
      } else if (isTRUE(length(emails) == nrow(record_au_table))) {
          ## assume that emails corresponds AU authors
          record_au_table[, author_email := emails]
      } else if (isTRUE(nrow(record_rp_table) != 0)) {
          ## in other cases just use first email for first RP author
          record_au_table[match(record_rp_table$author_name, author_name)[1]
                        , author_email := emails[1]]
      } else {
          ## if no RP assignt to first in AU
          record_au_table[1, author_email := emails[1]]
      }
      ## we do not need to return things as it updates record_au_table
      return(record_au_table)
  }


  ## tests
  ## disambr_eject_authors_parse_em(
  ## record_em = "a"
  ## , record_au_table = data.table(author_name = c(1,2,3,4))
  ## , record_rp_table = data.table(author_name = c(3))
  ## ) %>% print




  ##' Parses C1 (author adress/affiliation) column of WoS saved records export
  ##' @param record_c1 a record string from RP column
  ##' @return Data.table with two columns -  author_name and affiliations
  disambr_eject_authors_parse_c1 <- function(record_c1
                                           , table_af = NULL) {
      record_c1_init <- ""
      authors_table <-
          data.table::data.table()
      while(record_c1 != record_c1_init) {
          record_c1_init <- record_c1
          record_c1_piece <- 
              stringi::stri_match_first_regex(
                           record_c1, "\\s*\\[([^\\[\\]]+)\\]\\s+([^;]+)\\s*")
          authors <-
              stringi::stri_split_fixed(record_c1_piece[1,2], "; ")[[1]]
          affiliation <- record_c1_piece[1,3]
          for (author in authors) {
              ## check if author is already in the list
              authors_table_match <-
                  authors_table$author_full_name %in% author
              if(any(authors_table_match)) {
                  ## add affiliation to affiliations of author
                  ## the data.table way..
                  authors_table[authors_table_match
                              , affiliations :=
                                    list(c(unlist(affiliations), affiliation))]
              } else {
                  ## add new author with affiliation otherwise
                  authors_table <-
                      data.table::rbindlist(list(authors_table
                                               , list(author_full_name = author
                                                    , affiliations = list(affiliation))))
              }
          }
          record_c1 <-
              stringi::stri_replace_first_regex(
                           record_c1, "\\s*\\[[^\\[\\]]+\\][^;]+[;]", "")
      }
      ## merge with table_af if provided
      if(length(table_af) != 0) {
          return(authors_table[table_af
                             , on = "author_full_name"
                             , .(affiliations)
                             , roll = TRUE])
      } else {
          return(authors_table)
      }
  }



  ## "[Wang, Menglei; Li, Shunyi; Zhu, Rencheng; Zhang, Ruiqin] Zhengzhou Univ, Sch Ecol & Environm, Zhengzhou 450001, Peoples R China; [Wang, Menglei] Zhengzhou Univ, Sch Chem Engn, Zhengzhou 450001, Peoples R China; [Zu, Lei; Wang, Yunjing; Bao, Xiaofeng] Chinese Res Inst Environm Sci, State Environm Protect Key Lab Vehicle Emiss Cont, Beijing 100012, Peoples R China" %>%
  ## disambr_eject_authors_parse_c1


  ## "[Wang, Menglei; Li, Shunyi; Zhu, Rencheng; Zhang, Ruiqin] Zhengzhou Univ, Sch Ecol & Environm, Zhengzhou 450001, Peoples R China; [Wang, Menglei] Zhengzhou Univ, Sch Chem Engn, Zhengzhou 450001, Peoples R China; [Zu, Lei; Wang, Yunjing; Bao, Xiaofeng] Chinese Res Inst Environm Sci, State Environm Protect Key Lab Vehicle Emiss Cont, Beijing 100012, Peoples R China" %>%
  ## disambr_eject_authors_parse_c1(disambr_eject_authors_parse_af("Wang, Menglei; Li, Shunyi; Zhu, Rencheng; Zhang, Ruiqin; Zu, Lei; Wang, Yunjing; Bao, Xiaofeng"))






  ## ##' Parses RI (researcher_id) column of WoS saved records export
  ## ##' @param record_ri a record string from RP column
  ## ##' @param table_af 
  ## ##' @return Data.table with columns - author_full_name and author_researcher_id 
  ## disambr_eject_authors_parse_ri <- function(record_ri
  ##                                          , table_af = NULL) {
  ##     if(isTRUE(record_ri != "")) {
  ##         authors <- stringi::stri_split_fixed(record_ri, "; ")[[1]]
  ##         authors_list <- lapply(authors, function(author) {
  ##             author_split <- stringi::stri_split_fixed(author, "/", n = 2)[[1]]
  ##             list(author_full_name = author_split[1]
  ##                , author_researcher_id = author_split[2])
  ##         })
  ##         authors_table <- data.table::rbindlist(authors_list)
  ##     } else {
  ##         authors_table <- data.table::data.table(author_full_name = character()
  ##                                               , author_researcher_id = character())
  ##     }
  ##     ## merge with table_af if provided
  ##     if(length(table_af) != 0) {
  ##         return(authors_table[table_af
  ##                            , .(author_researcher_id)
  ##                            , on = "author_full_name"
  ##                            , roll = TRUE])
  ##     } else {
  ##         return(authors_table)
  ##     }
  ## }

  ## rbindlist(list("Girabent, Montserrat/B-8536-2008; Maydeu-Olivares, Alberto/B-5178-2010" %>%
  ## disambr_eject_authors_parse_ri
  ## , "" %>%
  ## disambr_eject_authors_parse_ri))


  ## a <- data.table(a1 = c(1,2,2,3,4), a2 = c(11,22,22,33,44))
  ## b <- data.table(a1 = c(3,2), b2 = c(333,111))


  ## a[b, on = "a1", roll = TRUE]

  ## b[a, on = "a1"]

  ## NA %>%
  ## disambr_eject_authors_parse_ri



  ## ##' Parses OI (ORCID) column of WoS saved records export
  ## ##' @param record_oi a record string from OI column
  ## ##' @return Data.table with columns - author_full_name and author_orcid
  ## disambr_eject_authors_parse_oi <- function(record_oi
  ##                                          , table_af = NULL) {
  ##     if(isTRUE(record_oi != "")) {
  ##         authors <- stringi::stri_split_fixed(record_oi, "; ")[[1]]
  ##         authors_list <- lapply(authors, function(author) {
  ##             author_split <- stringi::stri_split_fixed(author, "/", n = 2)[[1]]
  ##             list(author_full_name = author_split[1]
  ##                , author_orcid = author_split[2])
  ##         })
  ##         authors_table <- data.table::rbindlist(authors_list)
  ##     } else {
  ##         authors_table <- data.table::data.table(author_full_name = character()
  ##                                               , author_orcid = character())
  ##     }
  ##     ## merge with table_af if provided
  ##     if(length(table_af) != 0) {
  ##         return(authors_table[table_af
  ##                            , on = "author_full_name"
  ##                            , .(author_orcid)
  ##                            , roll = TRUE])
  ##     } else {
  ##         return(authors_table)
  ##     }
  ## }


  ## "Estrela, Pedro/0000-0001-6956-1146; Maxted, Grace/0000-0002-6816-9107; Rainbow, Joshua/0000-0003-3911-928X; Richtera, Lukas/0000-0002-8288-3999; Moschou, Despina/0000-0001-9175-5852" %>% disambr_eject_authors_parse_oi


  ##' Parses OI column of WoS saved records export
  ##' @param record_oi a record string from OI column
  ##' @return data.table
  ##' 
  ##' @md 
  disambr_eject_authors_parse_oi <- function(record_oi
                                            , table_af = NULL) {
      authors <- stringi::stri_split_fixed(record_oi, "; ")[[1]]
      author_full_name <-
          stringi::stri_extract_first_regex(authors, "^[^/]+")
      author_orcid <-
          stringi::stri_extract_first_regex(authors, "(?<=/).+")
      authors_table <- 
          data.table::data.table(author_full_name = author_full_name
                               , author_orcid = author_orcid)
      ## take care of propable case of multiple ID for one person
      author_full_name_unique <- unique(authors_table$author_full_name)
      author_orcid_list <-
          lapply(author_full_name_unique
               , function(x) {
                   authors_table$author_orcid[authors_table$author_full_name %in% x]
               })
      authors_table <-
          data.table::data.table(author_full_name = author_full_name_unique
                               , author_orcid = author_orcid_list)
      if(length(table_af) != 0) {
          return(authors_table[table_af
                             , on = "author_full_name"
                             , .(author_orcid)])
      } else {
          return(authors_table)
      }
  }



  ## "Estrela, Pedro/0000-0001-6956-1146; Maxted, Grace/0000-0002-6816-9107; Rainbow, Joshua/0000-0003-3911-928X; Richtera, Lukas/0000-0002-8288-3999; Moschou, Despina/0000-0001-9175-5852" %>%
      ## disambr_eject_authors__parse_oi



  ## "Estrela, Pedro/0000-0001-6956-1146; Maxted, Grace/0000-0002-6816-9107; Rainbow, Joshua/0000-0003-3911-928X; Rainbow, Joshua/0000-0003-3911-928X; Richtera, Lukas/0000-0002-8288-3999; Moschou, Despina/0000-0001-9175-5852" %>%
      ## disambr_eject_authors__parse_oi(
          ## table_af = data.table(author_full_name =
                                    ## c("Rainbow, Joshua", "Moschou, Despina")))                                                                                       

  ## "" %>% disambr_eject_authors__parse_oi(
             ## table_af = data.table(author_full_name = c("Rainbow, Joshua")))

  ## NA %>% disambr_eject_authors__parse_oi



  ##' Parses RI column of WoS saved records export
  ##' @param record_ri a record string from RI column
  ##' @return data.table
  ##' 
  ##' @md 
  disambr_eject_authors_parse_ri <- function(record_ri
                                            , table_af = NULL) {
      authors <- stringi::stri_split_fixed(record_ri, "; ")[[1]]
      author_full_name <-
          stringi::stri_extract_first_regex(authors, "^[^/]+")
      author_researcher_id <-
          stringi::stri_extract_first_regex(authors, "(?<=/).+")
      authors_table <- 
          data.table::data.table(author_full_name = author_full_name
                               , author_researcher_id = author_researcher_id)
      ## take care of propable case of multiple ID for one person
      author_full_name_unique <- unique(authors_table$author_full_name)
      author_researcher_id_list <-
          lapply(author_full_name_unique
               , function(x) {
                   authors_table$author_researcher_id[
                                     authors_table$author_full_name %in% x]
               })
      authors_table <-
          data.table::data.table(author_full_name = author_full_name_unique
                               , author_researcher_id = author_researcher_id_list)
      if(length(table_af) != 0) {
          return(authors_table[table_af
                             , on = "author_full_name"
                             , .(author_researcher_id)])
      } else {
          return(authors_table)
      }
  }




  ## related fields (as in Web of Science Field Tags 2018-06-27)
  ## au
  ## af full names
  ## - ba book
  ## - bf book
  ## - ca gp group author (usually organization or group name)
  ## - be editors
  ## c1 adresses
  ## rp reprint address (one you contact for reprint copy)
  ## em emails
  ## ri researcher ID
  ## oi ORCID Identifier (Open Researcher and Contributor ID)
  ## eject authors table (after combining initiall export tables)
  disambr_eject_authors <- function(wos_data_table
                                  , list_of_author_fields =
                                        c("author_order"
                                        , "author_short_name"
                                        , "author_initials"
                                        , "author_last_name"
                                        , "author_full_name"
                                        , "author_first_names"
                                        , "author_first_full_name"
                                        , "author_email"
                                        , "author_researcher_id"
                                        , "author_orcid"
                                        , "author_affiliations")
                                    , verbose = FALSE) {
      authors_tables <- list()
      ## AU
      if(any(c("author_order"
             , "author_short_name"
             , "author_last_name"
             , "author_initials"
             , "author_email") %in% list_of_author_fields) &&
         "AU" %in% names(wos_data_table)) {
          if(verbose) message("--- parsing AU field")
          authors_tables$au <-
              lapply(wos_data_table$AU
                              , disambr_eject_authors_parse_au)
      }
      ## AF
      if(any(c("author_full_name"
             , "author_first_names"
             , "author_first_full_name"
             , "author_researcher_id"
             , "author_orcid"
             , "author_affiliations") %in% list_of_author_fields) &&
         "AF" %in% names(wos_data_table)) {
          if(verbose) message("--- parsing AF field")
          authors_tables$af <-
              lapply(wos_data_table$AF
                   , disambr_eject_authors_parse_af)
      }
      ## RP
      if(any(c("author_email") %in% list_of_author_fields) &&
         "RP" %in% names(wos_data_table)) {
          if(verbose) message("--- parsing RP field")
          ## save RP separately as it is different order from AU
          rp <-
              lapply(wos_data_table$RP
                   , disambr_eject_authors_parse_rp)
      }

      ## EM
      if(any(c("author_email") %in% list_of_author_fields) &&
         all(c("AU", "EM", "RP") %in% names(wos_data_table))) {
          if(verbose) message("--- parsing EM field")
          ## disambr_eject_authors_parse_em updates authors_tables$au
          ## so no need to save it
          mapply(disambr_eject_authors_parse_em
               , wos_data_table$EM
               , authors_tables$au
               , rp
               , SIMPLIFY = FALSE
               , USE.NAMES = FALSE)
      }
      ## C1
      ## if(any(c("author_affiliations") %in% list_of_author_fields) &&
      ##    all(c("C1", "AF") %in% names(wos_data_table))) {
      ##     authors_tables$c1 <-
      ##         mapply(disambr_eject_authors_parse_c1
      ##              , wos_data_table$C1
      ##              , authors_tables$af
      ##              , SIMPLIFY = FALSE)
      ## }
      ## RI
      if(any(c("author_researcher_id") %in% list_of_author_fields) &&
         all(c("RI", "AF") %in% names(wos_data_table))) {
          if(verbose) message("--- parsing RI field")
          authors_tables$ri <-
              mapply(disambr_eject_authors_parse_ri
                   , wos_data_table$RI
                   , authors_tables$af
                   , SIMPLIFY = FALSE
                   , USE.NAMES = FALSE)
      }
      ## OI
      if(any(c("author_orcid") %in% list_of_author_fields) &&
         all(c("OI", "AF") %in% names(wos_data_table))) {
          if(verbose) message("--- parsing OI field")
          authors_tables$oi <-
              mapply(disambr_eject_authors_parse_oi
                   , wos_data_table$OI
                   , authors_tables$af
                   , SIMPLIFY = FALSE
                   , USE.NAMES = FALSE)
      }
      ## remove duplicated columns
      if(verbose) message("--- stacking author fields")
      authors_tables <- 
          lapply(authors_tables, rbindlist, idcol = "paper_id")
      authors_table <- do.call(cbind, c(authors_tables, list(deparse.level = 0)))
      authors_table_names <- 
          stringi::stri_replace_first_regex(names(authors_table), "^[^\\.]+\\.", "")
      authors_table_select <- which(!duplicated(authors_table_names))
      authors_table_new_names <- authors_table_names[authors_table_select]
      authors_table <- authors_table[, authors_table_select, with = FALSE]
      names(authors_table) <- authors_table_new_names
      ## set author attributes
      attributes(authors_table)$disambr_entity <- "person"
      attributes(authors_table)$disambr_entity_id_reference <-
                                  "wos_records_tsv_export"
      attributes(authors_table)$disambr_set_type <- "similar_entities"
      attributes(authors_table)$disambr_set_coefficient <- 0.1
      attributes(authors_table)$disambr_set_name <-
                                  "wos_records_tsv_export_author_table"
      attributes(authors_table)$disambr_set_collection <- "single_set_table"
      return(authors_table)
  }

  ## test
  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2)[[1]]
  ## dt %>% disambr_eject_authors

  ## testing dt merge
  ## a <- data.table(name = c("a", "b", "c"), order = c(1,2,3))
  ## b <- data.table(named = c("c", "b", "c"), affil = c("b-adfsa","c-sadfsd"))
  ## cbind(a, b, check.names = FALSE)

  ## ----------------------------------------------------------------------------

  ## CR (Cited References)

  disambr_parse_references <- function(record_cr) {
      references <- stringi::stri_split_fixed(record_cr, "; ")[[1]]
      references_list <- stringi::stri_split_fixed(references, ", ")
      references_list <-
          lapply(references_list, function(ref) {
              first_author_name <- ref[1]
              year <- ref[2]
              outlet <- ref[3]
              ref_tail <- ref[-c(1:3)]
              vol <- stringi::stri_extract_first_regex(ref_tail, "^V(\\d+)")
              vol <- vol[!sapply(vol, is.na)]
              page <- stringi::stri_extract_first_regex(ref_tail, "^P(\\d+)")
              page <- page[!sapply(page, is.na)]
              doi <- stringi::stri_extract_first_regex(ref_tail, "^DOI \\[*(.*)\\]*")
              doi <- doi[!sapply(doi, is.na)]
              ## combine
              list(first_author_name = ref[1]
                 , year = ref[2]
                 , outlet = ref[3]
                 , vol = vol
                 , page = page
                 , doi = doi)
          })
      suppressWarnings(rbindlist(references_list))
  }

  ## "Allen C, 2017, ENVIRON SCI-NANO, V4, P741, DOI 10.1039/c7en90014g; Baek YW, 2011, SCI TOTAL ENVIRON, V409, P1603, DOI 10.1016/j.scitotenv.2011.01.014; Baker GL, 2008, TOXICOL SCI, V101, P122, DOI 10.1093/toxsci/kfm243; Bergstrom U, 2015, J TOXICOL ENV HEAL A, V78, P645, DOI 10.1080/15287394.2015.1017682; Bhushan B, 2011, PROG MATER SCI, V56, P1, DOI 10.1016/j.pmatsci.2010.04.003; Biswas P, 2005, J AIR WASTE MANAGE, V55, P708, DOI 10.1080/10473289.2005.10464656; Bitterle E, 2006, CHEMOSPHERE, V65, P1784, DOI 10.1016/j.chemosphere.2006.04.035; Bondarenko O, 2013, ARCH TOXICOL, V87, P1181, DOI 10.1007/s00204-013-1079-4; Bonner J. C., 2003, ENV HLTH PERSPECT, V111, P1289; Brossell D, 2013, J AEROSOL SCI, V63, P75, DOI 10.1016/j.jaerosci.2013.04.012; Clift MJD, 2011, ARCH TOXICOL, V85, P723, DOI 10.1007/s00204-010-0560-6; Cohen J, 2013, NANOTOXICOLOGY, V7, P417, DOI 10.3109/17435390.2012.666576; Cohen JM, 2014, PART FIBRE TOXICOL, V11, DOI 10.1186/1743-8977-11-20; Comouth A, 2013, J AEROSOL SCI, V63, P103, DOI 10.1016/j.jaerosci.2013.04.009" %>% disambr_parse_references

  disambr_eject_references <- function(wos_data_table) {
      if("CR" %in% names(wos_data_table)) {
          references_list <-
              lapply(wos_data_table$CR, disambr_parse_references)
          references_table <-
              rbindlist(references_list, idcol = "paper_id")
      }
      ## set references attributes
      attributes(references_table)$disambr_entity <- "publication"
      attributes(references_table)$disambr_entity_id_reference <-
                                     "wos_records_tsv_export"
      attributes(references_table)$disambr_set_type <- "similar_entities"
      attributes(references_table)$disambr_set_coefficient <- 0.1
      attributes(references_table)$disambr_set_name <-
                                     "wos_records_tsv_export_reference_table"
      attributes(references_table)$disambr_set_collection <- "single_set_table"
      return(references_table)
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2)[[1]]
  ## dt %>% disambr_eject_references

#+END_SRC

** disambr_subsets
:PROPERTIES:
:ID:       org:vd6faz31gti0
:END:
#+BEGIN_SRC R :tangle R/disambr_sets.r
  ##' Filters list of sets
  ##' @param sets_list list of sets
  ##' @param attribute_value_list list of attribute values where list elements name correspond attribute names used for filtering sets
  ##' @param which_to_return whether to return "all", "first" or "last" set from filtered sets
  ##' @param negate_subsets whether to return sets that was not matched insted
  ##' @return list of sets or set if `which_to_return` is ethier "first" or "last"
  ##' 
  ##' @export 
  disambr_subsets <- function(sets_list, attribute_value_list
                            , which_to_return = c("all", "first", "last")
                            , negate_subsets = FALSE) {
      if (!is.list(sets_list))
          stop("disambr: 'sets_list' should be a list!")
      if (!is.list(attribute_value_list))
          stop("disambr: 'attribute_value_list' should be a list!")
      filter_sets <- function(attr_name, attr_value) {
          sapply(lapply(sets_list, attr, attr_name), `[`, 1) %in% attr_value
      }
      sets_list_filters <- mapply(filter_sets
                                , names(attribute_value_list)
                                , attribute_value_list
                                , SIMPLIFY = FALSE
                                , USE.NAMES = TRUE)
      subsets_list <-
          if (isTRUE(negate_subsets)) {
              sets_list[!Reduce(`&`, sets_list_filters)]
          } else {
              sets_list[Reduce(`&`, sets_list_filters)]
          }
      return(switch(which_to_return[1]
                  , all = subsets_list
                  , first = subsets_list[[1]]
                  , last = subsets_list[[length(subsets_list)]]))
  }



  ## a <- c(1,2,3,4)
  ## b <- c("a","b","c")
  ## c <- NULL
  ## attributes(a)$name <- "aaa"
  ## attributes(b)$name <- "bbb"
  ## attributes(c)$name <- c("ccc", 3)
  ## attributes(a)$kind <- "good"
  ## attributes(b)$kind <- "good"
  ## attributes(c)$kind <- "bad"

  ## disambr_subsets(list(a,b,c), list(kind = "good"))

  ## disambr_subsets(list(a,b,c), list(kind = "good"), which_to_return = "last")

  ## disambr_subsets(list(a,b,c), list(name = "ccc"
  ##                                 , kind = "good"))

  ## disambr_subsets(list(a,b,c), list(name = "ccc"
  ##                                 , kind = "bad"))
#+END_SRC

** disambr_set_attributes
:PROPERTIES:
:ID:       org:oak78r30hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_sets.r
  ## disambr_entity
  ## disambr_set_type
  ## disambr_set_coefficient
  ## disambr_set_name
  ## disambr_set_collection
  ## disambr_entity_id_reference
  ## disambr_entity_id_reference_md5_sum
  ## disambr_recipe
  disambr_set_attributes <- function(focal_set, ...) {
      attr_value_list <- list(...)
      for (i in 1:length(attr_value_list)) {
          attributes(focal_set)[[names(attr_value_list)[i]]] <-
              attr_value_list[[i]]
      }
      return(focal_set)
  }
#+END_SRC

** disambr_save_set
:PROPERTIES:
:ID:       org:7m03hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_sets.r
  disambr_save_set <- function(set_to_save
                             , save_set_as = TRUE
                             , use_time_stamp = TRUE) {
      if(length(save_set_as) != 0) {
          if(isTRUE(save_set_as)) {
              save_set_as <- attr(set_to_save, "disambr_set_name")
              if(isTRUE(use_time_stamp)) {
                  save_set_as <-
                      paste0(save_set_as, "."
                           , format(Sys.time(), "%Y-%m-%dT%H-%M"))

              }
              save_set_as <-
                  paste0("disambr_set."
                       , save_set_as
                       , ".rds")
          }
          if(is.character(save_set_as)) {
              saveRDS(set_to_save, file = save_set_as)
              message(
                  "- saved set as '", save_set_as, "'")
          } else {
              message(
                  "disambr: do not know how to save 'set_to_save' as '", save_set_as, "'")
          }
      }
       return()
   }
#+END_SRC

** disambr_read
:PROPERTIES:
:ID:       org:1p6ja7119ri0
:END:
#+BEGIN_SRC R :tangle R/disambr_read.r
  disambr_rbind_wos <- function(tables_list, tables_recipes) {
      publication_table <-
          data.table::rbindlist(tables_list, fill=TRUE)
      ## set publication attributes
      publication_table <-
          disambr_set_attributes(publication_table
                               , disambr_entity = "publication"
                               , disambr_entity_id_reference = "self"
                               , disambr_set_type = "different_entities"
                               , disambr_set_coefficient = 1
                               , disambr_set_name = "wos_records_tsv_export"
                               , disambr_set_collection = "single_set_table")
      ## add files recipies
      attributes(publication_table)$disambr_recipe <- tables_recipes
      return(publication_table)
  }




  disambr_process_files_data <- function(files_data_list, verbose = FALSE) {
      ## TODO: add other data processing here
      ## TODO: add processing of wos data with differen headers
      ## check wos publication
      processabe_data <-
          disambr_subsets(files_data_list
                        , list(disambr_set_name = "wos_records_tsv_export"))
      if (length(processabe_data) != 0) {
          processabe_data_recipes <-
              lapply(processabe_data, attr, "disambr_recipe")
          processabe_data_headers <-
              lapply(processabe_data_recipes, `[[`, "file_header")
          ## check if all headers ate the same before rbindlist
          if (length(unique(processabe_data_headers)) == 1) {
              message("disambr: processing wos tsv export data..")
              message("- rbinding wos tables..")
              wos_publication <-
                  disambr_rbind_wos(files_data_list, processabe_data_recipes)
              message("- ejecting wos authors..")
              wos_author <- disambr_eject_authors(wos_publication, verbose = TRUE)
              ## remove fields that we do not need
              remove_headers <- c("AU", "AF", "C1", "RP", "EM", "RI", "OI")
              ## filter those that exists
              remove_headers <-
                  remove_headers[remove_headers %in% processabe_data_headers[[1]]]
              ## remove headers without hard copy (to use a varialbe it should be in () )
              wos_publication[, (remove_headers) := NULL]
              message("- ejecting wos references..")
              wos_reference <- disambr_eject_references(wos_publication)
              ## remove fields that we do not need
              remove_headers <- c("CR")
              ## filter those that exists
              remove_headers <-
                  remove_headers[remove_headers %in% processabe_data_headers[[1]]]
              ## remove headers without hard copy (to use a varialbe it should be in () )
              wos_publication[, (remove_headers) := NULL]
              ## if all data is wos data return only that
              if(length(processabe_data) == length(files_data_list)) {
                  return(list(wos_publication
                            , wos_author
                            , wos_reference
                              ))
              } else {
                  return(list(
                      disambr_subsets(files_data_list
                                    , list(disambr_set_name = "wos_records_tsv_export")
                                    , negate_subsets = TRUE)
                    , wos_publication
                    , wos_author
                    , wos_reference
                  ))
              }
          } else {
              message("disambr: Files data has different headers. Skipping processing...")
              return(files_data_list)
          }
      } else {
          return(files_data_list)
      }
  }

  parse_tsv_wos_header <- function(first_line) {
      header <- stri_split_fixed(first_line, "\t")[[1]]
      if( ## check if at least 10 fields two big letters
          sum(stri_detect_regex(header, "^[A-Z0-9]{2}$")) > 10 &&
          ## check if main fields are present
          all(c('AU', 'TI') %in% header)) {
          stri_extract_first_regex(header, "[A-Z0-9]{2}")
      } else {FALSE}
  }


  disambr_read_tsv_wos <- function(f, header) {
      s <- read_to_utf8(f)
      s <- recode_return_characters(s, f)
      f_data <- fread(text = s
                    , skip = 1
                    , strip.white = TRUE
                    , header = FALSE
                    , col.names = header
                    , select = 1:length(header)
                      ## , colClasses = rep("character", length(header))
                    , quote=""
                    , keepLeadingZeros = FALSE
                    , encoding = "UTF-8"
                    , sep = "\t")
      ## set attrib (file, funcall, meanning of the fields and data scheme)
      ## TODO: this also can be a separate function to set atribute to data
      attributes(f_data)$disambr_entity <- "publication"
      attributes(f_data)$disambr_entity_id_reference <- "self"
      attributes(f_data)$disambr_set_type <- "different_entities"
      attributes(f_data)$disambr_set_coefficient <- 1
      attributes(f_data)$disambr_set_name <- "wos_records_tsv_export"
      attributes(f_data)$disambr_set_collection <- "single_set_table"
      attributes(f_data)$disambr_recipe <-
                           list(procedure = "disambr_read_tsv_wos"
                              , file_name = f
                              , file_md5sum = tools::md5sum(f)
                              , file_header = header
                              , procedure = "disambr_read_tsv_wos")
      return(f_data)
  }


  disambr_read_tsv <- function(f) {
      ## check tsv file type base on first line
      first_line <- readLines(f, n = 1
                            , warn = FALSE
                            , skipNul = TRUE)
      header <- parse_tsv_wos_header(first_line)
      if(!isFALSE(header)) {
          disambr_read_tsv_wos(f, header)
      } else {
          ## here we can add more tsv types
          message("Disambr: unrecognized header of tsv file: ", header
                , "\n  - skipping file: ", f)
          NULL
      }
  }

  disambr_read_file <- function(f) {
      f_extention <- tools::file_ext(f)
      switch(f_extention
           , "tsv" = disambr_read_tsv(f)
             ## here we can add reading from .txt wos files
           , "txt" = disambr_read_tsv(f)
           , message("Disambr: can not read file extention: ", f_extention
                   , "\n  - skipping file: ", f))
  }

  ##' Reads the data for disambiguation
  ##' @param files_path Path to data. You can specify almost everything
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @export 
  disambr_read <- function(files_path) {
      files_path <- parse_files_path(files_path)
      files_data_list <- lapply(files_path, disambr_read_file)
      sets <- disambr_process_files_data(files_data_list)
      return(sets)
  }



  ## my.dir <- '../data'
  ## my.dir.small <- '../data/Journals in Mathematical Psychology'
  ## my.dir.large <- '/mnt/md5/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments'
  ## my.dir.huge <- '/mnt/md5/data/wos'


  ## my.file <- '../data/Journals in Mathematical Psychology/Applied Psychological Measurement.txt' 
  ## my.file1 <- "/mnt/md5/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments/LN Public NAICS records from 10001 to 10500.txt"
  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## my.files <-
  ## c('../data/Journals in Mathematical Psychology/Applied Measurement in Education.txt'
  ## , '../data/Journals in Mathematical Psychology/Applied Psychological Measurement.txt')


  ## dt <- my.dir.small %>% disambr_read
  ## dt %>% length
#+END_SRC

** disambr_aev
:PROPERTIES:
:ID:       org:h938lox0gti0
:END:

*** disambr_set_tekles_bornmann
:PROPERTIES:
:ID:       org:8c83hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  disambr_set_tekles_bornmann <- function(sets
                                        , file_path = "../data/tekles_bornmann_rids.txt"
                                        , verbose = FALSE
                                        , save_set_as = TRUE
                                        , data_set_name = 
                                        "wos_records_tsv_export_author_table") {
      if(verbose) message("disambr: Starting disambr_set_tekles_bornmann...")
      if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
      data_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , which_to_return = "first")
      sets <- disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , negate_subsets = TRUE)
      if(verbose) message("- filtering authors from Tekles & Bornmann (2019)")
      researcher_ids <- readLines(file_path)
      data_set <- data_set[author_researcher_id %in% researcher_ids]
      data_set_recipe <- attr(data_set, "disambr_recipe")
      data_set <-
          disambr_set_attributes(data_set
                               , disambr_recipe = c(list("disambr_set_tekles_bornmann")
                                                  , data_set_recipe))
      disambr_save_set(data_set, save_set_as)
      return(c(sets, list(data_set)))
   }

  ## dt <- readRDS(file = "my.dir.wos.rds") %>%
      ## disambr_set_tekles_bornmann(verbose = TRUE) %>%
      ## disambr_set_on_same_paper(verbose = TRUE, save_set_as = TRUE)


  ## dt %>% length
  ## dt[[4]] %>% head


  ## after disambr_set_tekles_bornmann
  ## dt %>% length
  ## nrow(dt[[3]])
  ## 25868 vs 834090

#+END_SRC
*** disambr_set_on_same_paper
:PROPERTIES:
:ID:       org:iab3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  disambr_set_on_same_paper <- function(sets
                                        , verbose = FALSE
                                        , save_set_as = TRUE
                                        , data_set_name =
                                              "wos_records_tsv_export_author_table") {
      if(verbose) message("disambr: Starting disambr_set_not_on_same_paper...")
      if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
      data_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , which_to_return = "first")
      if(verbose) message("- spliting co-authors")
      return_sets <- data_set %>% {split(1:nrow(.), .$paper_id)}
      data_set_recipe <- attr(data_set, "disambr_recipe")
      return_sets <- 
             disambr_set_attributes(return_sets
                           , disambr_entity = "person"
                           , disambr_set_type = "different"
                           , disambr_set_coefficient = 1
                           , disambr_set_name = "on_same_paper"
                           , disambr_set_collection = "sets_list"
                           , disambr_entity_id_reference =
                                 "wos_records_tsv_export_author_table"
                           , disambr_recipe = c(list("disambr_set_on_same_paper")
                                              , data_set_recipe))
      disambr_save_set(return_sets, save_set_as)
      return(c(sets, list(return_sets)))
  }
#+END_SRC

*** disambr_set_not_on_same_paper
:PROPERTIES:
:ID:       org:nie3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ## too slow... and eats all ram
  disambr_set_not_on_same_paper <- function(sets
                                          , verbose = FALSE
                                          , save_set_as = TRUE
                                          , data_set_name =
                                                "wos_records_tsv_export_author_table") {
       if(verbose) message("disambr: Starting disambr_set_not_on_same_paper...")
       if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
       data_set <-
           disambr_subsets(sets
                         , list(disambr_set_name = data_set_name)
                         , which_to_return = "first")
       if(verbose) message("- spliting co-authors")
       return_sets <- data_set %>% {split(1:nrow(.), .$paper_id)}
       if(verbose) message("- making combinations of co-authors sets..")
       if(length(return_sets) > 50000) stop("--- THE NUMBER OF COMBINATIONS IS TO HIGH!")
       return_sets_comb <-
           combn(length(return_sets), 2, simplify = FALSE)
       if(verbose) message("--- made ,", length(return_sets_comb), " combinations")
       if(verbose) message("- expanding combinations")
       return_sets <-
           pblapply(return_sets_comb
                  , function(comb) {
                      expand.grid(author_id1 = return_sets[[comb[1]]]
                                , author_id2 = return_sets[[comb[2]]])
                  })
       if(verbose) message("- rbinding combinations..")
       return_sets <- data.table::rbindlist(return_sets)
       if(verbose) message("--- rbinded into ", nrow(return_sets), " rows")
       ## set set's attributes
       data_set_recipe <- attr(data_set, "disambr_recipe")
       return_sets <- 
           disambr_set_attributes(return_sets
                                , disambr_entity = "person"
                                , disambr_set_type = "similar"
                                , disambr_set_coefficient = 0.5
                                , disambr_set_name = "not_on_same_paper"
                                , disambr_set_collection = "dyads_table"
                                , disambr_entity_id_reference =
                                      "wos_records_tsv_export_author_table"
                                , disambr_recipe = c(list("disambr_set_not_on_same_paper")
                                                   , data_set_recipe))
       if(length(save_set_as) != 0)
       return(c(sets, list(return_sets)))
   }
#+END_SRC


*** disambr_set_similar_initials
:PROPERTIES:
:ID:       org:i1i3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  disambr_set_similar_initials <- function(sets
                                         , verbose = FALSE
                                         , save_set_as = TRUE
                                         , data_set_name =
                                               "wos_records_tsv_export_author_table"
                                         , input_set_name = "on_same_paper") {
      if(verbose) message("disambr: Starting disambr_set_similar_initials...")
      if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
      data_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , which_to_return = "first")
      input_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , which_to_return = "first")
      ## sets <- disambr_subsets(sets
      ##                       , list(disambr_set_name = data_set_name)
      ##                       , negate_subsets = TRUE)
      if(verbose) message("- doing combinations")
      input_set_l <- length(input_set)
      return_set <- 
          pblapply(1:input_set_l, function(i) {
              comb <- lapply((i+1):input_set_l
                           , function(j) {
                               expand.grid(author_id1 = input_set[[i]]
                                         , author_id2 = input_set[[j]])
                           })
              comb <- data.table::rbindlist(comb)
              comb_dist <- stringdist(data_set$author_initials[comb$author_id1]
                                    , data_set$author_initials[comb$author_id2]
                                    , method = "lv")
              return(comb[comb_dist < 2])
          })
      if(verbose) message("- rbinding dyads")
      return_set <- data.table::rbindlist(return_set)
      input_set_recipe <- attr(data_set, "disambr_recipe")
      return_set <-
          disambr_set_attributes(
              return_sets
            , disambr_entity = "person"
            , disambr_set_type = "similar"
            , disambr_set_coefficient = 0.5
            , disambr_set_name = "similar_initials"
            , disambr_set_collection = "dyads_table"
            , disambr_entity_id_reference =
                  "wos_records_tsv_export_author_table"
            , disambr_recipe = c(list("disambr_set_set_similar_initials")
                               , input_set_recipe))
      disambr_save_set(return_sets, save_set_as)
      return(c(sets, list(return_set)))
   }


    ## dt <- readRDS(file = "my.dir.wos.rds") %>%
        ## disambr_set_tekles_bornmann(verbose = TRUE) %>%
        ## disambr_set_on_same_paper(verbose = TRUE, save_set_as = TRUE) %>% 
        ## disambr_set_similar_initials(verbose = TRUE)
#+END_SRC


*** disambr_set_similar_last_names
:PROPERTIES:
:ID:       org:nnl3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  disambr_set_similar_last_names <- function(sets
                                           , verbose = FALSE
                                           , save_set_as = TRUE
                                           , data_set_name =
                                                 "wos_records_tsv_export_author_table"
                                           , input_set_name = "on_same_paper") {
      if(verbose) message("disambr: Starting disambr_set_similar_last_names...")
      if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
      data_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = data_set_name)
                        , which_to_return = "first")
      input_set <-
          disambr_subsets(sets
                        , list(disambr_set_name = input_set_name)
                        , which_to_return = "first")
      input_set_l <- length(input_set)
      if(verbose) message("- doing combinations on ", input_set_l)
      return_set <- 
          pblapply(1:input_set_l, function(i) {
              comb <- lapply((i+1):input_set_l
                           , function(j) {
                               expand.grid(author_id1 = input_set[[i]]
                                         , author_id2 = input_set[[j]])
                           })
              comb <- data.table::rbindlist(comb)
              comb_dist <- stringdist(data_set$author_last_name[comb$author_id1]
                                    , data_set$author_last_name[comb$author_id2]
                                    , method = "dl")
              return(comb[comb_dist < 2])
          })
      if(verbose) message("- rbinding dyads")
      return_set <- data.table::rbindlist(return_set)
      input_set_recipe <- attr(data_set, "disambr_recipe")
      return_set <-
          disambr_set_attributes(
              return_sets
            , disambr_entity = "person"
            , disambr_set_type = "similar"
            , disambr_set_coefficient = 0.5
            , disambr_set_name = "similar_last_names"
            , disambr_set_collection = "dyads_table"
            , disambr_entity_id_reference =
                  "wos_records_tsv_export_author_table"
            , disambr_recipe = c(list("disambr_set_similar_last_names")
                               , input_set_recipe))
      disambr_save_set(return_sets, save_set_as)
      return(c(sets, list(return_set)))
   }


    ## dt <- readRDS(file = "my.dir.wos.rds") %>%
        ## disambr_set_tekles_bornmann(verbose = TRUE) %>%
        ## disambr_set_on_same_paper(verbose = TRUE, save_set_as = TRUE) %>% 
        ## disambr_set_similar_last_names(verbose = TRUE)
#+END_SRC

** disambr_aev_depricated
*** disambr_set_co_authors                                     :depricated:
:PROPERTIES:
:ID:       org:2mo3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
##' Returns sets of people ids that are defenetely different based on co-authorship
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_set_co_authors <- function(sets, procedures = NULL) {
      message("disambr: Starting disambr_set_co_authors...")
      if(!is.list(sets)) stop("disambr: 'sets' parameter should be list!")
      disambr_subsets("person")
      focal.set <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          ## TODO: implement extraction from different data type
          extract2(1)
      new.set <- focal.set %>%
          {split(1:nrow(.), .$paper_id)}
      ## set set's attributes
      attributes(new.set)$disambr.set.unit <- "person.distinct"
      attributes(new.set)$disambr.set.unit.ref.md5 <- digest(focal.set, "md5")
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>% disambr_set_co_authors
  ## dt[[4]]


#+END_SRC
*** disambr_get_3_refs_common                                  :depricated:
:PROPERTIES:
:ID:       org:amr3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r

  ##' Returns set of people with save email addresses
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_3_refs_common <- function(sets, procedures = NULL) {
      message("Starting disambr_get_3_refs_common...")
      ## TODO: extract teh set that we need here (person, dyads)
      similar.last.names <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "similar.last.names") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      new.set <-
          similar.last.names %>% 
          dplyr::mutate(same.affiliations =
                            mapply(function(var1, var2)
                                any(set.data$author_affiliations[var1] %in% 
                                    set.data$author_affiliations[var2])
                            , Var1, Var2))
      ## new.set <- dplyr::filter(new.set, last.name.dist < 2)
      attributes(new.set)$disambr.set.unit <- "same.affiliation"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials %>%
      ## disambr_get_similar_last_names %>% 
      ## disambr_get_same_affiliation
  ## dt[[7]]$same.affiliations
#+END_SRC

*** disambr_get_same_affiliation                               :depricated:
:PROPERTIES:
:ID:       org:nqu3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ##' Returns set of people with save email addresses
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_same_affiliation <- function(sets, procedures = NULL) {
      message("Starting disambr_get_same_affiliation...")
      ## TODO: extract teh set that we need here (person, dyads)
      similar.last.names <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "similar.last.names") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      new.set <-
          similar.last.names %>% 
          dplyr::mutate(same.affiliations =
                            mapply(function(var1, var2)
                                any(set.data$author_affiliations[var1] %in% 
                                    set.data$author_affiliations[var2])
                            , Var1, Var2))
      ## new.set <- dplyr::filter(new.set, last.name.dist < 2)
      attributes(new.set)$disambr.set.unit <- "same.affiliation"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials %>%
      ## disambr_get_similar_last_names %>% 
      ## disambr_get_same_affiliation
  ## dt[[7]]$same.affiliations
#+END_SRC

*** disambr_get_same_coauthor                                  :depricated:
:PROPERTIES:
:ID:       org:hwx3hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ##' Returns set of people with save email addresses
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_same_coauthor <- function(sets, procedures = NULL) {
      message("Starting disambr_get_same_email...")
      ## TODO: extract teh set that we need here (person, dyads)
      similar.last.names <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "similar.last.names") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      fun <- function(var1, var2) {
          any(set.data[paper_id %in% paper_id[var1] &
                       !(author_name %in% author_name[var1])]$author_name %in% 
              set.data[paper_id %in% paper_id[var2] &
                       !(author_name %in% author_name[var2])]$author_name)
      }
      new.set <-
          similar.last.names %>% 
          dplyr::mutate(
                     same.co.author = mapply(fun, Var1, Var2))
      ## new.set <- dplyr::filter(new.set, last.name.dist < 2)
      attributes(new.set)$disambr.set.unit <- "same.email"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials %>%
      ## disambr_get_similar_last_names %>% 
      ## disambr_get_same_coauthor

  ## dt[[7]]
#+END_SRC


*** disambr_get_similar_last_names                             :depricated:
:PROPERTIES:
:ID:       org:y114hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ##' Returns set of people with similar last names
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_similar_last_names <- function(sets, procedures = NULL) {
      message("Starting disambr_get_similar_last_names...")
      ## TODO: extract teh set that we need here (person, dyads)
      set.similar.initials <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "similar.initials") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      new.set <-
          dplyr::mutate(
                     set.similar.initials
                   , last.name.dist =
                         stringdist(set.data$author_last_name[Var1]
                                  , set.data$author_last_name[Var2]
                                  , method = "dl"))
      new.set <- dplyr::filter(new.set, last.name.dist < 2)
      attributes(new.set)$disambr.set.unit <- "similar.last.names"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials %>%
      ## disambr_get_similar_last_names
  ## dt[[6]]
#+END_SRC

*** disambr_get_same_email                                     :depricated:
:PROPERTIES:
:ID:       org:e544hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ##' Returns set of people with save email addresses
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_same_email <- function(sets, procedures = NULL) {
      message("Starting disambr_get_same_email...")
      ## TODO: extract teh set that we need here (person, dyads)
      similar.last.names <- sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "similar.last.names") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      new.set <-
          similar.last.names %>% 
          dplyr::mutate(same.email = mapply(function(var1, var2)
                            set.data$author_email[var1] == set.data$author_email[var2]
                            , Var1, Var2))
      ## new.set <- dplyr::filter(new.set, last.name.dist < 2)
      attributes(new.set)$disambr.set.unit <- "same.email"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials %>%
      ## disambr_get_similar_last_names %>% 
      ## disambr_get_same_email
#+END_SRC




*** disambr_get_similar_initials                               :depricated:
:PROPERTIES:
:ID:       org:lk74hcq0hti0
:END:
#+BEGIN_SRC R :tangle R/disambr_eva.r
  ##' Returns set of people with similar initials
  ##' @param sets 
  ##' @param procedures 
  ##' @inheritDotParams 
  ##' @return 
  ##' 
  ##' @md 
  ##' @importFrom magrittr %>%
  ##' @import magrittr data.table dplyr stringr
  ##' @export 
  disambr_get_similar_initials <- function(sets, procedures = NULL) {
      message("Starting disambr_get_similar_initials...")
      ## sapply(sets,attr, "disambr.set.unit")
      set.different.authors <-
          sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person.distinct") %>%
          extract2(1)
      set.data <-sets %>%
          extract(sapply(.,attr, "disambr.set.unit") == "person") %>%
          extract2(1)
      ## procedurs
      subset.similar.initials <- function(comb) {
          a <- set.different.authors[[comb[1]]]
          b <- set.different.authors[[comb[2]]]
          expand.grid(a, b)
      }
      new.set <- combn(1:length(set.different.authors), 2
                     , simplify = FALSE
                       ## , FUN = subset.similar.initials
                       )
      message("...combn produced ", length(new.set), " pairs of pubs")
      new.set <- pblapply(new.set, subset.similar.initials)
      message("...subset.similar.initials is done")
      new.set <- data.table::rbindlist(new.set)
      message("...rbindlist produced ", nrow(new.set), " pairs")
      new.set <- dplyr::mutate(new.set
                             , initials.dist =
                                   stringdist(set.data$author_initials[Var1]
                                            , set.data$author_initials[Var2]
                                            , method = "lv"))
      new.set <- dplyr::filter(new.set, initials.dist < 2)
      attributes(new.set)$disambr.set.unit <- "similar.initials"
      return(c(sets, list(new.set)))
  }

  ## my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  ## dt <- disambr_read(my.file2) %>%
      ## disambr_set_co_authors %>%
      ## disambr_get_similar_initials
  ## dt[[5]]

#+END_SRC

** tests

#+BEGIN_SRC R :results none :session :tangle no
  my.dir <- '../data'
  my.dir.small <- '../data/Journals in Mathematical Psychology'
  my.dir.large <- '/mnt/md5/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments'
  my.dir.huge <- '/mnt/md5/data/wos'

  my.file <- '../data/Journals in Mathematical Psychology/Applied Psychological Measurement.txt' 
  my.file1 <- "/mnt/md5/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments/LN Public NAICS records from 10001 to 10500.txt"
  my.files <-
      c('../data/Journals in Mathematical Psychology/Applied Measurement in Education.txt'
      , '../data/Journals in Mathematical Psychology/Applied Psychological Measurement.txt')


  ## ----------------------------------------------------------------------------

  my.dat <- disambr.read(my.dir)

  my.dat <- disambr.read(my.file)

  attributes(my.dat[[1]])

  my.dat <- disambr.read("../data/new_export")

  my.dat[[1]]$RP[1:4]
  my.dat[[1]]$EM[1:4]

  my.dat <- 
      my.dat %>%
      disambr.get.different.authors


  my.dat[[2]]


  my.dat %>% 
      disambr.get.different.authors %>% 
      disambr.get.similar.initials %>%
      disambr.get.similar.last.names


  dat <- disambr.read(my.file)

  dat %>% extract(1) %>% disambr.get.different.authors


  ## new testing
  d <- disambr.read("../data/wos-researchers-ids")

  d <- d[[1]][1:1000,] %>% list

  d.done <- 
      d %>% 
      disambr.get.different.authors %>% 
      disambr.get.similar.initials  %>%


  d.done %>% length

  d.done2 %>% length

  d.done2[[4]] %>% nrow

  d.done2 <- 
      d.done %>%
      disambr.get.similar.last.names

  saveRDS(d.done2, "../data/d.done2.rds")




  disambr.eva <- function(data) {
      data %>% 
          disambr.get.different.authors %>% 
          disambr.get.similar.initials %>%
          disambr.get.similar.last.names
  }

  ## Usage
  disambr.eva(data)


  disambr.get.different.authors <- disambr.define.procedure(data %>% 
                                                            get(publication) %>%
                                                            for.each %>%
                                                            get(person = author))

  ## or
  disambr.get.different.authors <- disambr.define.procedure(data$
                                                            publication$
                                                            person(author))





  list(data = my.dat
     , similar.initials = set.similar.initials) %>% 
      disambr.get.similar.last.names


  set.different.authors <- disambr.get.different.authors(my.dat)

  set.similar.initials <- 
      list(data = my.dat
         , different.authors = set.different.authors) %>% 
      disambr.get.similar.initials




  ## 2020-08-25

  ## problem with large integers
  bit64

  return_sets_comb <-
          combn(1:100000, 2, simplify = FALSE)

  10,000,000,000

  return_sets_comb %>% length

  install.packages("bit64")
  as.integer64
  library("bit64")

  .Machine$integer.max
  [1] 2147483647


  combn(3, 2, simplify = FALSE)

  my.dir.small <- '../data/Journals in Mathematical Psychology'

  my.dir.large <- '/run/media/stas/ed6193a5-e4fd-4d83-9eb6-e481c39aeb8f/data/wos/wos-sci-expanded.firm-names-query.analytical-instruments'


  my.dir.wos <- "~/home/web of science"

  my.file2 <- "../data/new_export/savedrecs-ms-recent.txt"
  my.file2 <- "../data/wos-researchers-ids"


  dt <- disambr_read(my.dir.wos) %T>%
      saveRDS(file = "my.dir.wos.rds", compress = FALSE)


  dt <- readRDS(file = "my.dir.wos.rds") %>% 
      disambr_set_not_on_same_paper(verbose = TRUE)



  dt <- disambr_read(my.dir.large) %T>%
      saveRDS(file = "my.dir.large.rds", compress = FALSE) %>% 
      disambr_set_not_on_same_paper(verbose = TRUE)

  dt <- readRDS(file = "my.dir.large.rds") %>% 
      disambr_set_not_on_same_paper(verbose = TRUE)

  dt[[4]]
#+END_SRC

Testing help

#+BEGIN_SRC R :results none :session :tangle no
  options(browser="firefox")
  help(disambr.read, help_type = "html")
#+END_SRC

** testthat
:PROPERTIES:
:ID:       org:w9t7lox0gti0
:END:

#+BEGIN_SRC R :results none :session :tangle tests/testthat/test.stop.unless.r :mkdirp yes
test_that("stop.unless", {
      expect_warning(stop.unless(FALSE, "Lala", FALSE))
      expect_error(stop.unless(FALSE))
      expect_true(stop.unless(TRUE))
      expect_false(stop.unless("sdfasdf", stop.if.false = FALSE))
      expect_true(stop.unless("sdfasdf", stop.if.false = FALSE, return.if.true = FALSE))
  })
#+END_SRC


#+BEGIN_SRC R :results none :session :tangle tests/testthat/test.parse.files.path.r :mkdirp yes
    test_that("parse.files.path", {
          expect_error(parse.files.path(3423))
          expect_warning(parse.files.path(c(".", "gibirish file")))
          expect_is(parse.files.path("."), "character")
          ## empty dirs
          tmp.dir <- "test_dir_for_parse.files.path"
          dir.create(tmp.dir, showWarnings = FALSE)
          expect_equal(parse.files.path(tmp.dir), character(0))
          file.remove(tmp.dir)
      })
#+END_SRC

